<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22021544-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script');
    ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(ga, s);
  })();

</script>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'aartamonau'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.

    // hardcoding this for now
    var disqus_identifier = 'haskell_holes';
    var disqus_url = 'http://github.com/shaleny/haskell-holes';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"></meta>
    <title>haskell-holes</title>
    <!-- Stylesheets. -->
    <link rel="stylesheet" type="text/css" href="css/default.css"></link>
    <link rel="stylesheet" type="text/css" href="css/syntax.css"></link>
  </head>

  <body>
    <div class="wrapper">

      <div class="header">
        <a href="http://github.com/shaleny/haskell-holes">
          <img class="forkme" src="images/forkme.png" alt="Fork me on GitHub"></img>
        </a>
        <h1>haskell-holes</h1>
      </div>

      <div class="content">
           <h2 id="rationale">Rationale</h2>
<p><strong>Clojure</strong> programming language has a prominent reader form which enables you to define anonymous functions in a slightly less verbose way. For instance, instead of writing <code>(fn [x y z] (+ x (/ z y)))</code> you can just express it as <code>#(+ %1 (/ %3 %2))</code>. In <strong>Haskell</strong> we sometimes use point-free style to achieve similar goals. Though the result can be disappointing as regards the readability of the result (no doubt that it heavily depends on the function to be defined in such way). Another issue I sometimes have is the need to invent meaningful names for the parameters which is not always possible. Such a shortcut form allows to use just a number to identify parameters. Though I can define lambda as <code>\_1 _2 _3 -&gt; _1 + (_3 / _2)</code> I don’t find it appropriate. It feels much better psychologically when it’s not you who makes hacky (or just not very beautiful) things but some automated machinery. That’s why this package exists.</p>
<h2 id="usage">Usage</h2>
<p><strong>Haskell-holes</strong> package is implemented as a Template Haskell quasi-quoter (more on implementation details in the next section). So the meaningless example from the previous section can be rewritten using <strong>haskell-holes</strong> as follows:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Language.Haskell.Holes</span><br /><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>t [<span class="fu">$</span>holes<span class="fu">|</span> <span class="fu">%</span><span class="dv">1</span> <span class="fu">+</span> (<span class="fu">%</span><span class="dv">3</span> <span class="fu">/</span> <span class="fu">%</span><span class="dv">2</span>) <span class="fu">|</span>]<br />[<span class="fu">$</span>holes<span class="fu">|</span> <span class="fu">%</span><span class="dv">1</span> <span class="fu">+</span> (<span class="fu">%</span><span class="dv">3</span> <span class="fu">/</span> <span class="fu">%</span><span class="dv">2</span>) <span class="fu">|</span>]<span class="ot"> </span><span class="ot">::</span> (<span class="kw">Fractional</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p>Up to 9 numbered arguments are supported (<code>%1</code> through <code>%9</code>). Though there is no way to say “all arguments altogether” (in <strong>Clojure</strong> it’s just <code>%</code>). The number of arguments which the anonymous function will take is determined by the maximum argument number that is used in its body. Another syntactic limitation: to avoid ambiguity <code>%</code> should be surrounded by spaces if it’s used in its usual meaning.</p>
<p>Using <strong>haskell-holes</strong> standard <em>map</em> function can be defined (rather cryptically) as follows:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Data.Function</span><br /><span class="kw">import</span> <span class="dt">Language.Haskell.Holes</span><br /><br /><span class="fu">&gt;&gt;&gt;</span> <span class="kw">let</span> <span class="fu">map</span> <span class="fu">=</span> fix <span class="fu">$</span> [holes<span class="fu">|</span> <span class="kw">if</span> <span class="fu">null</span> <span class="fu">%</span><span class="dv">3</span> <span class="kw">then</span> [] <span class="kw">else</span> <span class="fu">%</span><span class="dv">2</span> (<span class="fu">head</span> <span class="fu">%</span><span class="dv">3</span>) <span class="fu">:</span> <span class="fu">%</span><span class="dv">1</span> <span class="fu">%</span><span class="dv">2</span> (<span class="fu">tail</span> <span class="fu">%</span><span class="dv">3</span>) <span class="fu">|</span>]<br /><span class="fu">&gt;&gt;&gt;</span> <span class="fu">:</span>t <span class="fu">map</span><br /><span class="fu">map</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [t]</code></pre>
<h2 id="reflections">Reflections</h2>
<p>This is my first experience with <strong>Template Haskell</strong> and quasi-quoters. An overall impression is positive: it’s nice to know that if you are not satisfied with expressiveness of <strong>Haskell</strong> you can use <strong>TH</strong> as a last resort. Though it was quite disappointing to realize that in order to <em>extend</em> syntax slightly you need to implement full-featured <strong>Haskell</strong> parser. So my big thanks goes to <a href="http://hackage.haskell.org/package/haskell-src-exts">haskell-src-exts</a> and <a href="http://hackage.haskell.org/package/haskell-src-meta">haskell-src-meta</a> projects which can parse source code in <strong>Haskell</strong> into a <strong>TH</strong> abstract syntax. But I think that many people will agree with me that it would be nice to see this functionality eventually in <strong>GHC</strong> out of the box.</p>

           <div id="disqus_thread"></div>
      </div>
    </div>

    <div class="footer">
      <div>
        Site proudly generated by
        <a href="http://github.com/jaspervdj/hakyll">hakyll</a>.
      </div>
      <div>
        <a href="http://disqus.com" class="dsq-brlink">
          blog comments powered by <span class="logo-disqus">Disqus</span>
        </a>
      </div>
    </div>

  </body>
</html>
